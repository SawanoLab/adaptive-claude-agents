# v0.7.0-beta Week 1 Kickoff

**Date**: 2025-10-23
**Week**: Week 1 of 4 (Performance & CLI Enhancement)
**Status**: 🚀 READY TO START
**Theme**: Performance Optimization & Error Recovery

---

## 📋 Week 1 Overview

**Goals**:
1. Performance: 6/11 → 9/11 frameworks < 500μs
2. Caching: Implement filesystem-based cache
3. CLI: Add 4 new flags (--framework, --cache, --debug, --profile)
4. Error Recovery: Graceful degradation, better logging

**Timeline**: 7 days (Nov 1-7, 2025 planned)

---

## 🎯 Day 1-2: Performance Profiling & Optimization Setup

### Objectives

**Day 1 Morning**:
- [ ] Establish performance baseline (all 11 frameworks)
- [ ] Run existing performance benchmarks
- [ ] Document current performance metrics

**Day 1 Afternoon**:
- [ ] Profile detection code with cProfile/line_profiler
- [ ] Identify top 3 bottlenecks
- [ ] Research faster parsing libraries

**Day 2 Morning**:
- [ ] Design caching strategy (key generation, invalidation)
- [ ] Set up performance benchmark suite
- [ ] Create performance tracking spreadsheet

**Day 2 Afternoon**:
- [ ] Research orjson vs ujson vs standard json
- [ ] Test YAML parsing alternatives (PyYAML vs ruamel.yaml)
- [ ] Document optimization opportunities

### Current Performance Baseline (v0.6.0)

**Fast Frameworks** (< 500μs): **6/11 (55%)**
```
Next.js:     119.4μs  ✅ FAST
React:       177.2μs  ✅ FAST
Vue:         231.8μs  ✅ FAST
Django:      289.1μs  ✅ FAST
FastAPI:     441.6μs  ✅ FAST
Flask:       422.9μs  ✅ FAST
```

**Target for Optimization** (500μs → <250μs): **3 frameworks**
```
Go:          523.8μs  ❌ SLOW → Target: <250μs (-52%)
PHP:         555.1μs  ❌ SLOW → Target: <250μs (-55%)
iOS Swift:   851.6μs  ❌ SLOW → Target: <500μs (-41%)
Python ML:  1012.1μs  ❌ SLOW → Target: <500μs (-51%)
Flutter:     973.0μs  ❌ SLOW → Target: <500μs (-49%)
```

**v0.7.0 Target**: **9/11 frameworks < 500μs (82%)**

### Profiling Commands

**Run performance benchmarks**:
```bash
cd /path/to/adaptive-claude-agents

# Full benchmark suite
python3 -m pytest tests/test_performance.py --benchmark-only

# Specific framework
python3 -m pytest tests/test_performance.py::TestDetectionPerformance::test_fastapi_detection_speed --benchmark-only

# With profiling
python3 -m cProfile -o profile.stats skills/project-analyzer/detect_stack.py /path/to/test-project

# Analyze profile
python3 -m pstats profile.stats
```

**Line profiler** (for detailed analysis):
```bash
# Install line_profiler
pip install line_profiler

# Profile specific function
kernprof -l -v skills/project-analyzer/detect_stack.py /path/to/test-project
```

### Expected Bottlenecks

**Hypothesis**:
1. **JSON Parsing** (package.json, composer.json, etc.)
   - Standard `json.load()` may be slow for large files
   - Solution: Try `orjson` (3-10x faster)

2. **YAML Parsing** (pubspec.yaml, go.mod, etc.)
   - PyYAML is known to be slow
   - Solution: Try `ruamel.yaml` with C extensions

3. **File I/O** (multiple file reads)
   - Sequential file reading in monorepos
   - Solution: Parallel file scanning with ThreadPoolExecutor

4. **Regex Matching** (pattern detection)
   - Complex regex patterns in detection logic
   - Solution: Pre-compile regex, simplify patterns

### Performance Tracking Template

Create: `docs/internal/v0.7.0_PERFORMANCE_TRACKING.md`

```markdown
# v0.7.0 Performance Tracking

## Baseline (v0.6.0)
| Framework | Time (μs) | Status | Target (μs) |
|-----------|-----------|--------|-------------|
| Next.js   | 119.4     | ✅ FAST | -           |
| React     | 177.2     | ✅ FAST | -           |
| Vue       | 231.8     | ✅ FAST | -           |
| Django    | 289.1     | ✅ FAST | -           |
| FastAPI   | 441.6     | ✅ FAST | -           |
| Flask     | 422.9     | ✅ FAST | -           |
| Go        | 523.8     | ❌ SLOW | <250        |
| PHP       | 555.1     | ❌ SLOW | <250        |
| iOS       | 851.6     | ❌ SLOW | <500        |
| Python ML | 1012.1    | ❌ SLOW | <500        |
| Flutter   | 973.0     | ❌ SLOW | <500        |

## Day 1 Progress
- [ ] Baseline established
- [ ] Profiling complete
- [ ] Top 3 bottlenecks identified

## Day 2 Progress
- [ ] Optimization strategy defined
- [ ] Parsing library research complete
- [ ] Caching design documented
```

---

## 🔬 Research Tasks

### JSON Parsing Libraries

**orjson** (Recommended):
- **Speed**: 3-10x faster than standard json
- **Pros**: C extension, battle-tested, drop-in replacement
- **Cons**: Requires compilation (may not work on all platforms)
- **Installation**: `pip install orjson`
- **Usage**:
  ```python
  import orjson
  data = orjson.loads(file_content)
  ```

**ujson** (Alternative):
- **Speed**: 2-5x faster than standard json
- **Pros**: Widely used, stable
- **Cons**: Less feature-complete than orjson
- **Installation**: `pip install ujson`

**Benchmark Test**:
```python
import json
import orjson
import ujson
import timeit

large_json = {...}  # 100+ dependencies in package.json

# Standard json
t1 = timeit.timeit(lambda: json.loads(large_json), number=1000)

# orjson
t2 = timeit.timeit(lambda: orjson.loads(large_json), number=1000)

# ujson
t3 = timeit.timeit(lambda: ujson.loads(large_json), number=1000)

print(f"json: {t1:.4f}s, orjson: {t2:.4f}s, ujson: {t3:.4f}s")
```

### YAML Parsing Libraries

**ruamel.yaml** (with C extensions):
- **Speed**: 2-3x faster than PyYAML
- **Pros**: Drop-in replacement, better YAML 1.2 support
- **Cons**: Slightly more complex API
- **Installation**: `pip install ruamel.yaml`

**Keep PyYAML**:
- **Speed**: Slower but sufficient for small files
- **Pros**: Standard library-like, simple API
- **Decision**: Profile first, optimize if needed

---

## 🗄️ Caching Strategy Design

### Cache Key Generation

**Strategy**: Path + mtime hash + version

```python
import hashlib
from pathlib import Path

def generate_cache_key(project_path: Path, version: str) -> str:
    """Generate unique cache key for project detection."""
    abs_path = project_path.resolve()

    # Get mtime of key files (package.json, go.mod, etc.)
    key_files = [
        abs_path / "package.json",
        abs_path / "go.mod",
        abs_path / "pubspec.yaml",
        # ... etc
    ]

    mtimes = []
    for f in key_files:
        if f.exists():
            mtimes.append(f.stat().st_mtime)

    mtime_hash = hashlib.sha256(
        str(sorted(mtimes)).encode()
    ).hexdigest()[:16]

    return f"{abs_path}:{mtime_hash}:{version}"
```

### Cache Storage

**Location**: `~/.cache/adaptive-claude-agents/`

**Structure**:
```
~/.cache/adaptive-claude-agents/
  ├── detection_cache.json      # Detection results cache
  ├── metadata.json              # Cache metadata
  └── locks/                     # Lock files for concurrency
```

**detection_cache.json**:
```json
{
  "/path/to/project:abc123:0.7.0": {
    "framework": "nextjs",
    "version": "14.2.0",
    "language": "typescript",
    "confidence": 1.0,
    "timestamp": 1698768000,
    "ttl": 86400
  }
}
```

**metadata.json**:
```json
{
  "version": "0.7.0-beta",
  "created": 1698768000,
  "last_cleanup": 1698768000,
  "entry_count": 42
}
```

### Cache Invalidation Rules

1. **File mtime change**: Invalidate immediately
2. **Version mismatch**: Invalidate on version upgrade
3. **TTL expiration**: Default 24 hours (configurable)
4. **Manual**: `--no-cache` flag
5. **Cleanup**: Remove entries older than 7 days

### Expected Performance

**Cache Hit** (best case):
- Read cache file: ~5μs
- Deserialize JSON: ~5μs
- **Total: ~10μs** (vs 100-1000μs detection)

**Cache Miss** (worst case):
- Full detection: 100-1000μs
- Write cache: ~10μs
- **Total: 110-1010μs** (10μs overhead)

**Hit Rate Estimate**: 60-80% in typical development workflow

---

## 🖥️ CLI Enhancement Design

### New Flags

**1. --framework FLAG**:
```bash
# Manual framework specification (bypass detection)
python3 detect_stack.py . --framework nextjs

# Use case: Detection fails or incorrect
python3 detect_stack.py /path/to/project --framework fastapi --auto
```

**Implementation**:
```python
parser.add_argument(
    '--framework',
    type=str,
    choices=['nextjs', 'react', 'vue', 'fastapi', 'django', 'flask',
             'go', 'flutter', 'php', 'ios-swift', 'python-ml'],
    help='Manually specify framework (bypass detection)'
)
```

**2. --cache / --no-cache FLAGS**:
```bash
# Use cache (default)
python3 detect_stack.py . --cache

# Bypass cache (force fresh detection)
python3 detect_stack.py . --no-cache
```

**Implementation**:
```python
cache_group = parser.add_mutually_exclusive_group()
cache_group.add_argument(
    '--cache',
    action='store_true',
    default=True,
    help='Use detection cache (default)'
)
cache_group.add_argument(
    '--no-cache',
    action='store_true',
    help='Bypass cache, force fresh detection'
)
```

**3. --debug FLAG**:
```bash
# Enable debug logging
python3 detect_stack.py . --debug

# Output: Detailed detection reasoning, timing, cache hits/misses
```

**Implementation**:
```python
parser.add_argument(
    '--debug',
    action='store_true',
    help='Enable debug logging'
)

# In code:
if args.debug:
    logging.basicConfig(level=logging.DEBUG)
    logger.debug(f"Cache key: {cache_key}")
    logger.debug(f"Detection time: {elapsed_time:.2f}μs")
```

**4. --profile FLAG**:
```bash
# Show performance profiling
python3 detect_stack.py . --profile

# Output:
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Performance Profile
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Total time:        1234.5μs
# File I/O:          234.5μs (19.0%)
# JSON parsing:      456.7μs (37.0%)
# Detection logic:   543.3μs (44.0%)
# Cache write:       10.0μs (0.8%)
```

**Implementation**:
```python
import time
from contextlib import contextmanager

@contextmanager
def profile_section(name: str, profile_data: dict):
    start = time.perf_counter()
    yield
    elapsed = (time.perf_counter() - start) * 1_000_000  # μs
    profile_data[name] = elapsed

# Usage:
profile_data = {}
with profile_section("File I/O", profile_data):
    # ... file operations
with profile_section("JSON parsing", profile_data):
    # ... JSON parsing
```

---

## 🚨 Error Recovery Design

### Graceful Degradation Strategy

**Scenario 1: Detection Fails (Unknown Project)**

**Before (v0.6.0)**:
```
❌ Could not detect framework
```

**After (v0.7.0)**:
```
⚠️  Could not automatically detect framework

💡 Suggestions:
  1. Manually specify framework:
     python3 detect_stack.py . --framework nextjs

  2. Check if project structure is valid:
     - JavaScript/TypeScript: package.json exists?
     - Python: requirements.txt or pyproject.toml exists?
     - Go: go.mod exists?

  3. Run with debug logging:
     python3 detect_stack.py . --debug

  4. Report issue: https://github.com/SawanoLab/adaptive-claude-agents/issues
```

**Scenario 2: Invalid Configuration File**

**Before (v0.6.0)**:
```
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
```

**After (v0.7.0)**:
```
⚠️  Could not parse package.json (invalid JSON)

📝 Details:
  File: /path/to/project/package.json
  Error: Expecting value: line 5 column 12

💡 Suggestions:
  1. Validate JSON: https://jsonlint.com/
  2. Check for syntax errors (trailing commas, etc.)
  3. Use --framework flag to bypass detection:
     python3 detect_stack.py . --framework nextjs
```

### Structured Logging

**Implementation**:
```python
import logging
from rich.logging import RichHandler

# Configure logging
logging.basicConfig(
    level=logging.INFO,  # DEBUG if --debug flag
    format="%(message)s",
    handlers=[RichHandler(rich_tracebacks=True)]
)

logger = logging.getLogger("adaptive-claude-agents")

# Usage:
logger.debug(f"Checking {project_path}")
logger.info("✓ Framework detected: Next.js 14.2.0")
logger.warning("⚠️  pubspec.yaml not found, skipping Flutter detection")
logger.error("❌ Could not parse package.json")
```

---

## 📊 Success Criteria (Week 1)

### Must Have (Blocking)
- ✅ 9/11 frameworks < 500μs (performance target)
- ✅ Caching system implemented and tested
- ✅ CLI enhancement (4 flags) working
- ✅ Error recovery system in place
- ✅ 20+ performance tests added

### Should Have
- ✅ 75%+ code coverage (from 72.53%)
- ✅ Cache hit rate 60%+
- ✅ All flags documented in --help

### Nice to Have
- ⏳ Parallel file scanning (defer if complex)
- ⏳ Advanced profiling dashboard (defer to v0.8.0)

---

## 📝 Daily Checklist

### Day 1
- [ ] Run baseline performance benchmarks (all 11 frameworks)
- [ ] Document current performance in tracking sheet
- [ ] Profile with cProfile, identify top 3 bottlenecks
- [ ] Research orjson/ujson performance

### Day 2
- [ ] Design cache key generation strategy
- [ ] Design cache storage structure
- [ ] Design cache invalidation rules
- [ ] Test JSON parsing library alternatives
- [ ] Document optimization plan

---

**Status**: 🚀 READY TO START
**Next**: Begin Day 1 - Performance Profiling

**Repository**: https://github.com/SawanoLab/adaptive-claude-agents
**Version**: v0.7.0-beta (in development - Week 1)
