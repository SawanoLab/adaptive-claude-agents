# Smart Invalidation Design - v0.7.0-beta Day 2

**Date**: 2025-10-23
**Focus**: Selective cache invalidation based on actual file usage
**Goal**: Reduce false invalidations, improve cache hit rate

---

## 🎯 Problem Statement

### Current Implementation (Week 1)
```python
def generate_key(project_path):
    # Monitor 21 indicator files
    key_files = [
        "package.json", "package-lock.json",
        "go.mod", "go.sum",
        "requirements.txt", "Pipfile",
        # ... and 15 more
    ]
    mtime_hash = compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**Problem**: **False invalidation**
- `README.md`を編集 → `package.json`は不変 → しかしキャッシュ無効化される
- 実際には**検出に使われていないファイル**の変更でもキャッシュが消える

**Impact**:
- キャッシュヒット率が本来より低い
- ユーザーがドキュメントを編集しただけで再検出が走る

---

## 💡 Solution: Smart Invalidation

### Core Idea
**「実際に読み取ったファイルのみ監視する」**

```python
# Detection時に使用したファイルを記録
used_files = []

if package_json.exists():
    content = package_json.read_text()  # ← 実際に読んだ
    used_files.append("package.json")

if next_config.exists():
    used_files.append("next.config.js")  # ← 実際に使った

# キャッシュキーは「使用したファイルのみ」で生成
cache_key = generate_key(path, used_files=used_files)
```

**Result**:
- `package.json`変更 → キャッシュ無効化 ✅
- `README.md`変更 → キャッシュ維持 ✅
- False invalidation **大幅削減**

---

## 🏗️ Architecture Design

### 1. Detection Result に used_files を追加

**Current**:
```python
@dataclass
class DetectionResult:
    framework: str
    version: str
    confidence: float
    indicators: List[str]
    # ...
```

**New**:
```python
@dataclass
class DetectionResult:
    framework: str
    version: str
    confidence: float
    indicators: List[str]
    used_files: List[str]  # ← NEW: 検出に使用したファイルリスト
    # ...
```

**Example**:
```python
DetectionResult(
    framework="nextjs",
    version="14.0.0",
    used_files=[
        "package.json",       # ← 実際に読んだ
        "package-lock.json",  # ← 実際に読んだ
        "next.config.js",     # ← 存在確認した
        "pages/",             # ← ディレクトリ確認した
    ]
)
```

---

### 2. TechStackDetector に file tracking を追加

**Implementation Strategy**:

```python
class TechStackDetector:
    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.used_files = []  # ← NEW: Track used files

    def _read_file(self, relative_path: str) -> Optional[str]:
        """Read file and track usage."""
        file_path = self.project_path / relative_path
        if file_path.exists():
            self.used_files.append(relative_path)  # ← Track
            return file_path.read_text()
        return None

    def _check_file(self, relative_path: str) -> bool:
        """Check file existence and track."""
        file_path = self.project_path / relative_path
        exists = file_path.exists()
        if exists:
            self.used_files.append(relative_path)  # ← Track
        return exists

    def detect(self) -> DetectionResult:
        # Use _read_file() and _check_file() instead of direct access
        package_json = self._read_file("package.json")
        has_next_config = self._check_file("next.config.js")

        # ... detection logic ...

        return DetectionResult(
            framework="nextjs",
            # ...
            used_files=self.used_files  # ← Include tracked files
        )
```

**Benefits**:
- Automatic tracking（明示的に追跡する必要なし）
- Centralized logic（`_read_file()` / `_check_file()`のみ修正）
- Easy to maintain

---

### 3. Cache key generation を更新

**Current**:
```python
def generate_key(project_path: Path) -> str:
    # All 21 indicator files
    key_files = _get_key_indicator_files(project_path)
    mtime_hash = _compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**New**:
```python
def generate_key(project_path: Path, used_files: List[str] = None) -> str:
    # Only files actually used during detection
    if used_files:
        key_files = [project_path / f for f in used_files]
    else:
        # Fallback: use all indicator files (backward compatible)
        key_files = _get_key_indicator_files(project_path)

    mtime_hash = _compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**Cache storage**:
```python
def set(self, project_path: Path, result: Dict):
    # Extract used_files from result
    used_files = result.get("used_files", [])

    # Generate key with used_files
    key = self.generate_key(project_path, used_files=used_files)

    # Store with metadata
    entry = {
        "result": result,
        "used_files": used_files,  # ← Store for future lookups
        "cached_at": time.time(),
    }
    cache_data[key] = entry
```

**Cache retrieval**:
```python
def get(self, project_path: Path) -> Optional[Dict]:
    # Load cache
    cache_data = self._load_cache()

    # Try all cached entries (may have different used_files)
    for key, entry in cache_data.items():
        if key.startswith(path_hash):
            used_files = entry.get("used_files", [])

            # Re-generate key with same used_files
            current_key = self.generate_key(project_path, used_files)

            if current_key == key:
                return entry["result"]  # Cache hit!

    return None  # Cache miss
```

---

## 📊 Expected Impact

### False Invalidation Reduction

**Scenario 1: Documentation update**
```bash
# User edits README.md
echo "# Updated docs" >> README.md

# Current behavior:
# - mtime of project changes
# - All 21 indicator files re-hashed
# - Cache key changes → Miss ❌

# New behavior:
# - README.md not in used_files
# - Cache key unchanged → Hit ✅
```

**Scenario 2: Test file update**
```bash
# User updates test file
echo "test('new test', () => {})" >> tests/example.test.js

# Current: Cache miss ❌
# New: Cache hit ✅ (tests/ not in used_files)
```

**Scenario 3: Actual config change**
```bash
# User updates package.json
npm install some-new-package

# Current: Cache miss ✅ (correct)
# New: Cache miss ✅ (still correct, package.json in used_files)
```

### Estimated Improvement
| Metric | Current | With Smart Invalidation | Improvement |
|--------|---------|------------------------|-------------|
| Cache hit rate | 87% | **92-95%** | +5-8% |
| False invalidations | ~15-20% | **<5%** | -10-15% |
| User experience | Good | Excellent | Fewer re-detections |

---

## 🔄 Migration Strategy

### Phase 1: Add used_files tracking (Day 2 Morning)
1. Update `DetectionResult` dataclass
2. Add `_read_file()` / `_check_file()` to `TechStackDetector`
3. Update all framework detection methods

**Time estimate**: 2 hours

### Phase 2: Update cache key generation (Day 2 Afternoon)
1. Modify `generate_key()` to accept `used_files`
2. Update `cache.set()` to store `used_files`
3. Update `cache.get()` to use stored `used_files`

**Time estimate**: 1.5 hours

### Phase 3: Testing & Validation (Day 2 Evening)
1. Unit tests for `_read_file()` / `_check_file()`
2. Integration test: file change scenarios
3. Benchmark: cache hit rate improvement

**Time estimate**: 1.5 hours

---

## 🧪 Testing Plan

### Test 1: Tracking Verification
```python
def test_used_files_tracking():
    detector = TechStackDetector(Path("/tmp/test-nextjs"))
    result = detector.detect()

    assert "package.json" in result.used_files
    assert "next.config.js" in result.used_files
    assert "README.md" not in result.used_files  # Not used
```

### Test 2: False Invalidation Prevention
```python
def test_smart_invalidation():
    cache = DetectionCache()
    project = Path("/tmp/test-nextjs")

    # First detection (cold start)
    result1 = detect_tech_stack(project)
    cache.set(project, result1.to_dict())

    # Modify file NOT in used_files
    (project / "README.md").write_text("Updated docs")

    # Should still hit cache
    cached = cache.get(project)
    assert cached is not None  # ✅ Cache hit!
```

### Test 3: Correct Invalidation
```python
def test_correct_invalidation():
    cache = DetectionCache()
    project = Path("/tmp/test-nextjs")

    # First detection
    result1 = detect_tech_stack(project)
    cache.set(project, result1.to_dict())

    # Modify file IN used_files
    pkg = project / "package.json"
    data = json.loads(pkg.read_text())
    data["version"] = "2.0.0"
    pkg.write_text(json.dumps(data))

    # Should invalidate cache
    cached = cache.get(project)
    assert cached is None  # ✅ Cache miss (correct!)
```

---

## 🎯 Success Criteria

- [ ] `used_files` added to `DetectionResult`
- [ ] `_read_file()` / `_check_file()` implemented
- [ ] All framework detectors updated (11/11)
- [ ] Cache key generation uses `used_files`
- [ ] Tests pass (3/3)
- [ ] Cache hit rate improvement: +5% minimum
- [ ] False invalidation rate: <5%

---

## 📝 Implementation Checklist

### Code Changes
- [ ] Update `DetectionResult` dataclass (+2 lines)
- [ ] Add `_read_file()` method (+8 lines)
- [ ] Add `_check_file()` method (+7 lines)
- [ ] Add `_check_dir()` method (+7 lines)
- [ ] Update `detect_nextjs()` to use helpers (~10 changes)
- [ ] Update `detect_fastapi()` (~8 changes)
- [ ] Update `detect_python_ml_cv()` (~6 changes)
- [ ] ... (8 more frameworks)
- [ ] Update `generate_key()` signature (+2 lines)
- [ ] Update `cache.set()` (+3 lines)
- [ ] Update `cache.get()` logic (+10 lines)

**Total code changes**: ~150 lines modified, ~50 lines added

### Tests
- [ ] `test_used_files_tracking()` (+15 lines)
- [ ] `test_smart_invalidation()` (+20 lines)
- [ ] `test_correct_invalidation()` (+25 lines)

**Total test additions**: ~60 lines

### Documentation
- [ ] Update cache design doc
- [ ] Day 2 completion report
- [ ] CHANGELOG.md entry

---

## 🔍 Edge Cases

### Edge Case 1: No files used (detection failed)
```python
result = DetectionResult(
    framework=None,
    used_files=[]  # ← Empty
)

# Solution: Fallback to full indicator list
cache_key = generate_key(path, used_files=[] or None)  # → uses all 21 files
```

### Edge Case 2: Directory vs. file tracking
```python
# User has pages/ directory
used_files = ["pages/"]  # Directory

# Check mtime of directory itself
dir_mtime = (project / "pages").stat().st_mtime

# OR: Check any file inside changed
any_file_changed = any(
    f.stat().st_mtime > cache_time
    for f in (project / "pages").rglob("*")
)
```

**Decision**: Track directory mtime only (simpler, faster)

### Edge Case 3: Symlinks
```python
# package.json is a symlink
(project / "package.json").is_symlink()  # True

# Solution: Resolve symlink before tracking
real_path = (project / "package.json").resolve()
used_files.append(str(real_path.relative_to(project)))
```

---

## 📚 References

- [Week 1 Caching Design](v0.7.0_CACHING_DESIGN.md)
- [Day 1 Analysis](v0.7.0_DAY1_CACHE_ANALYSIS.md)
- [Python pathlib documentation](https://docs.python.org/3/library/pathlib.html)
- [File system best practices](https://realpython.com/working-with-files-in-python/)

---

**Status**: Design complete, ready for implementation
**Next**: Implement Phase 1 (used_files tracking)
**ETA**: Day 2 completion by EOD

Repository: https://github.com/SawanoLab/adaptive-claude-agents
