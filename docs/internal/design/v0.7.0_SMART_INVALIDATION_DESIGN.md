# Smart Invalidation Design - v0.7.0-beta Day 2

**Date**: 2025-10-23
**Focus**: Selective cache invalidation based on actual file usage
**Goal**: Reduce false invalidations, improve cache hit rate

---

## üéØ Problem Statement

### Current Implementation (Week 1)
```python
def generate_key(project_path):
    # Monitor 21 indicator files
    key_files = [
        "package.json", "package-lock.json",
        "go.mod", "go.sum",
        "requirements.txt", "Pipfile",
        # ... and 15 more
    ]
    mtime_hash = compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**Problem**: **False invalidation**
- `README.md`„ÇíÁ∑®ÈõÜ ‚Üí `package.json`„ÅØ‰∏çÂ§â ‚Üí „Åó„Åã„Åó„Ç≠„É£„ÉÉ„Ç∑„É•ÁÑ°ÂäπÂåñ„Åï„Çå„Çã
- ÂÆüÈöõ„Å´„ÅØ**Ê§úÂá∫„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´**„ÅÆÂ§âÊõ¥„Åß„ÇÇ„Ç≠„É£„ÉÉ„Ç∑„É•„ÅåÊ∂à„Åà„Çã

**Impact**:
- „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„ÉàÁéá„ÅåÊú¨Êù•„Çà„Çä‰Ωé„ÅÑ
- „É¶„Éº„Ç∂„Éº„Åå„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÁ∑®ÈõÜ„Åó„Åü„Å†„Åë„ÅßÂÜçÊ§úÂá∫„ÅåËµ∞„Çã

---

## üí° Solution: Smart Invalidation

### Core Idea
**„ÄåÂÆüÈöõ„Å´Ë™≠„ÅøÂèñ„Å£„Åü„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÁõ£Ë¶ñ„Åô„Çã„Äç**

```python
# DetectionÊôÇ„Å´‰ΩøÁî®„Åó„Åü„Éï„Ç°„Ç§„É´„ÇíË®òÈå≤
used_files = []

if package_json.exists():
    content = package_json.read_text()  # ‚Üê ÂÆüÈöõ„Å´Ë™≠„Çì„Å†
    used_files.append("package.json")

if next_config.exists():
    used_files.append("next.config.js")  # ‚Üê ÂÆüÈöõ„Å´‰Ωø„Å£„Åü

# „Ç≠„É£„ÉÉ„Ç∑„É•„Ç≠„Éº„ÅØ„Äå‰ΩøÁî®„Åó„Åü„Éï„Ç°„Ç§„É´„ÅÆ„Åø„Äç„ÅßÁîüÊàê
cache_key = generate_key(path, used_files=used_files)
```

**Result**:
- `package.json`Â§âÊõ¥ ‚Üí „Ç≠„É£„ÉÉ„Ç∑„É•ÁÑ°ÂäπÂåñ ‚úÖ
- `README.md`Â§âÊõ¥ ‚Üí „Ç≠„É£„ÉÉ„Ç∑„É•Á∂≠ÊåÅ ‚úÖ
- False invalidation **Â§ßÂπÖÂâäÊ∏õ**

---

## üèóÔ∏è Architecture Design

### 1. Detection Result „Å´ used_files „ÇíËøΩÂä†

**Current**:
```python
@dataclass
class DetectionResult:
    framework: str
    version: str
    confidence: float
    indicators: List[str]
    # ...
```

**New**:
```python
@dataclass
class DetectionResult:
    framework: str
    version: str
    confidence: float
    indicators: List[str]
    used_files: List[str]  # ‚Üê NEW: Ê§úÂá∫„Å´‰ΩøÁî®„Åó„Åü„Éï„Ç°„Ç§„É´„É™„Çπ„Éà
    # ...
```

**Example**:
```python
DetectionResult(
    framework="nextjs",
    version="14.0.0",
    used_files=[
        "package.json",       # ‚Üê ÂÆüÈöõ„Å´Ë™≠„Çì„Å†
        "package-lock.json",  # ‚Üê ÂÆüÈöõ„Å´Ë™≠„Çì„Å†
        "next.config.js",     # ‚Üê Â≠òÂú®Á¢∫Ë™ç„Åó„Åü
        "pages/",             # ‚Üê „Éá„Ç£„É¨„ÇØ„Éà„É™Á¢∫Ë™ç„Åó„Åü
    ]
)
```

---

### 2. TechStackDetector „Å´ file tracking „ÇíËøΩÂä†

**Implementation Strategy**:

```python
class TechStackDetector:
    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.used_files = []  # ‚Üê NEW: Track used files

    def _read_file(self, relative_path: str) -> Optional[str]:
        """Read file and track usage."""
        file_path = self.project_path / relative_path
        if file_path.exists():
            self.used_files.append(relative_path)  # ‚Üê Track
            return file_path.read_text()
        return None

    def _check_file(self, relative_path: str) -> bool:
        """Check file existence and track."""
        file_path = self.project_path / relative_path
        exists = file_path.exists()
        if exists:
            self.used_files.append(relative_path)  # ‚Üê Track
        return exists

    def detect(self) -> DetectionResult:
        # Use _read_file() and _check_file() instead of direct access
        package_json = self._read_file("package.json")
        has_next_config = self._check_file("next.config.js")

        # ... detection logic ...

        return DetectionResult(
            framework="nextjs",
            # ...
            used_files=self.used_files  # ‚Üê Include tracked files
        )
```

**Benefits**:
- Automatic trackingÔºàÊòéÁ§∫ÁöÑ„Å´ËøΩË∑°„Åô„ÇãÂøÖË¶Å„Å™„ÅóÔºâ
- Centralized logicÔºà`_read_file()` / `_check_file()`„ÅÆ„Åø‰øÆÊ≠£Ôºâ
- Easy to maintain

---

### 3. Cache key generation „ÇíÊõ¥Êñ∞

**Current**:
```python
def generate_key(project_path: Path) -> str:
    # All 21 indicator files
    key_files = _get_key_indicator_files(project_path)
    mtime_hash = _compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**New**:
```python
def generate_key(project_path: Path, used_files: List[str] = None) -> str:
    # Only files actually used during detection
    if used_files:
        key_files = [project_path / f for f in used_files]
    else:
        # Fallback: use all indicator files (backward compatible)
        key_files = _get_key_indicator_files(project_path)

    mtime_hash = _compute_mtime_hash(key_files)
    return f"{path_hash}:{mtime_hash}:{version}"
```

**Cache storage**:
```python
def set(self, project_path: Path, result: Dict):
    # Extract used_files from result
    used_files = result.get("used_files", [])

    # Generate key with used_files
    key = self.generate_key(project_path, used_files=used_files)

    # Store with metadata
    entry = {
        "result": result,
        "used_files": used_files,  # ‚Üê Store for future lookups
        "cached_at": time.time(),
    }
    cache_data[key] = entry
```

**Cache retrieval**:
```python
def get(self, project_path: Path) -> Optional[Dict]:
    # Load cache
    cache_data = self._load_cache()

    # Try all cached entries (may have different used_files)
    for key, entry in cache_data.items():
        if key.startswith(path_hash):
            used_files = entry.get("used_files", [])

            # Re-generate key with same used_files
            current_key = self.generate_key(project_path, used_files)

            if current_key == key:
                return entry["result"]  # Cache hit!

    return None  # Cache miss
```

---

## üìä Expected Impact

### False Invalidation Reduction

**Scenario 1: Documentation update**
```bash
# User edits README.md
echo "# Updated docs" >> README.md

# Current behavior:
# - mtime of project changes
# - All 21 indicator files re-hashed
# - Cache key changes ‚Üí Miss ‚ùå

# New behavior:
# - README.md not in used_files
# - Cache key unchanged ‚Üí Hit ‚úÖ
```

**Scenario 2: Test file update**
```bash
# User updates test file
echo "test('new test', () => {})" >> tests/example.test.js

# Current: Cache miss ‚ùå
# New: Cache hit ‚úÖ (tests/ not in used_files)
```

**Scenario 3: Actual config change**
```bash
# User updates package.json
npm install some-new-package

# Current: Cache miss ‚úÖ (correct)
# New: Cache miss ‚úÖ (still correct, package.json in used_files)
```

### Estimated Improvement
| Metric | Current | With Smart Invalidation | Improvement |
|--------|---------|------------------------|-------------|
| Cache hit rate | 87% | **92-95%** | +5-8% |
| False invalidations | ~15-20% | **<5%** | -10-15% |
| User experience | Good | Excellent | Fewer re-detections |

---

## üîÑ Migration Strategy

### Phase 1: Add used_files tracking (Day 2 Morning)
1. Update `DetectionResult` dataclass
2. Add `_read_file()` / `_check_file()` to `TechStackDetector`
3. Update all framework detection methods

**Time estimate**: 2 hours

### Phase 2: Update cache key generation (Day 2 Afternoon)
1. Modify `generate_key()` to accept `used_files`
2. Update `cache.set()` to store `used_files`
3. Update `cache.get()` to use stored `used_files`

**Time estimate**: 1.5 hours

### Phase 3: Testing & Validation (Day 2 Evening)
1. Unit tests for `_read_file()` / `_check_file()`
2. Integration test: file change scenarios
3. Benchmark: cache hit rate improvement

**Time estimate**: 1.5 hours

---

## üß™ Testing Plan

### Test 1: Tracking Verification
```python
def test_used_files_tracking():
    detector = TechStackDetector(Path("/tmp/test-nextjs"))
    result = detector.detect()

    assert "package.json" in result.used_files
    assert "next.config.js" in result.used_files
    assert "README.md" not in result.used_files  # Not used
```

### Test 2: False Invalidation Prevention
```python
def test_smart_invalidation():
    cache = DetectionCache()
    project = Path("/tmp/test-nextjs")

    # First detection (cold start)
    result1 = detect_tech_stack(project)
    cache.set(project, result1.to_dict())

    # Modify file NOT in used_files
    (project / "README.md").write_text("Updated docs")

    # Should still hit cache
    cached = cache.get(project)
    assert cached is not None  # ‚úÖ Cache hit!
```

### Test 3: Correct Invalidation
```python
def test_correct_invalidation():
    cache = DetectionCache()
    project = Path("/tmp/test-nextjs")

    # First detection
    result1 = detect_tech_stack(project)
    cache.set(project, result1.to_dict())

    # Modify file IN used_files
    pkg = project / "package.json"
    data = json.loads(pkg.read_text())
    data["version"] = "2.0.0"
    pkg.write_text(json.dumps(data))

    # Should invalidate cache
    cached = cache.get(project)
    assert cached is None  # ‚úÖ Cache miss (correct!)
```

---

## üéØ Success Criteria

- [ ] `used_files` added to `DetectionResult`
- [ ] `_read_file()` / `_check_file()` implemented
- [ ] All framework detectors updated (11/11)
- [ ] Cache key generation uses `used_files`
- [ ] Tests pass (3/3)
- [ ] Cache hit rate improvement: +5% minimum
- [ ] False invalidation rate: <5%

---

## üìù Implementation Checklist

### Code Changes
- [ ] Update `DetectionResult` dataclass (+2 lines)
- [ ] Add `_read_file()` method (+8 lines)
- [ ] Add `_check_file()` method (+7 lines)
- [ ] Add `_check_dir()` method (+7 lines)
- [ ] Update `detect_nextjs()` to use helpers (~10 changes)
- [ ] Update `detect_fastapi()` (~8 changes)
- [ ] Update `detect_python_ml_cv()` (~6 changes)
- [ ] ... (8 more frameworks)
- [ ] Update `generate_key()` signature (+2 lines)
- [ ] Update `cache.set()` (+3 lines)
- [ ] Update `cache.get()` logic (+10 lines)

**Total code changes**: ~150 lines modified, ~50 lines added

### Tests
- [ ] `test_used_files_tracking()` (+15 lines)
- [ ] `test_smart_invalidation()` (+20 lines)
- [ ] `test_correct_invalidation()` (+25 lines)

**Total test additions**: ~60 lines

### Documentation
- [ ] Update cache design doc
- [ ] Day 2 completion report
- [ ] CHANGELOG.md entry

---

## üîç Edge Cases

### Edge Case 1: No files used (detection failed)
```python
result = DetectionResult(
    framework=None,
    used_files=[]  # ‚Üê Empty
)

# Solution: Fallback to full indicator list
cache_key = generate_key(path, used_files=[] or None)  # ‚Üí uses all 21 files
```

### Edge Case 2: Directory vs. file tracking
```python
# User has pages/ directory
used_files = ["pages/"]  # Directory

# Check mtime of directory itself
dir_mtime = (project / "pages").stat().st_mtime

# OR: Check any file inside changed
any_file_changed = any(
    f.stat().st_mtime > cache_time
    for f in (project / "pages").rglob("*")
)
```

**Decision**: Track directory mtime only (simpler, faster)

### Edge Case 3: Symlinks
```python
# package.json is a symlink
(project / "package.json").is_symlink()  # True

# Solution: Resolve symlink before tracking
real_path = (project / "package.json").resolve()
used_files.append(str(real_path.relative_to(project)))
```

---

## üìö References

- [Week 1 Caching Design](v0.7.0_CACHING_DESIGN.md)
- [Day 1 Analysis](v0.7.0_DAY1_CACHE_ANALYSIS.md)
- [Python pathlib documentation](https://docs.python.org/3/library/pathlib.html)
- [File system best practices](https://realpython.com/working-with-files-in-python/)

---

**Status**: Design complete, ready for implementation
**Next**: Implement Phase 1 (used_files tracking)
**ETA**: Day 2 completion by EOD

Repository: https://github.com/SawanoLab/adaptive-claude-agents
